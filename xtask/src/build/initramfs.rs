//! Initramfs creation module
//!
//! `TEAM_466`: Extracted from commands.rs during refactor.
//! Consolidates all initramfs creation logic with deduplicated CPIO helper.

use anyhow::{bail, Context, Result};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};

/// Shell test scripts embedded at compile time
const TEST_SH: &str = include_str!("../../initrd_resources/test.sh");
const TEST_CORE_SH: &str = include_str!("../../initrd_resources/test-core.sh");

/// Create a CPIO archive from a directory.
/// Shared helper to eliminate duplicate code across initramfs builders.
fn create_cpio_archive(root: &Path, output_filename: &str) -> Result<()> {
    let cpio_file = std::fs::File::create(output_filename)?;

    let find = Command::new("find")
        .current_dir(root)
        .arg(".")
        .stdout(Stdio::piped())
        .spawn()
        .context("Failed to run find")?;

    let mut cpio = Command::new("cpio")
        .current_dir(root)
        .args(["-o", "-H", "newc"])
        .stdin(find.stdout.unwrap())
        .stdout(cpio_file)
        .spawn()
        .context("Failed to run cpio")?;

    let status = cpio.wait()?;
    if !status.success() {
        bail!("cpio failed");
    }

    Ok(())
}

/// Set file as executable (Unix only)
#[cfg(unix)]
fn make_executable(path: &Path) -> Result<()> {
    use std::os::unix::fs::PermissionsExt;
    let mut perms = std::fs::metadata(path)?.permissions();
    perms.set_mode(0o755);
    std::fs::set_permissions(path, perms)?;
    Ok(())
}

#[cfg(not(unix))]
fn make_executable(_path: &Path) -> Result<()> {
    Ok(())
}

/// `TEAM_451`: Create BusyBox-based initramfs
/// Single binary provides init, shell, and 300+ utilities
pub fn create_busybox_initramfs(arch: &str) -> Result<()> {
    println!("üì¶ Creating BusyBox initramfs for {arch}...");

    // Require BusyBox to be built
    let busybox_path = super::busybox::require(arch)?;

    let root = PathBuf::from("initrd_root");

    // Clean and create directory structure
    if root.exists() {
        std::fs::remove_dir_all(&root)?;
    }
    std::fs::create_dir_all(&root)?;
    std::fs::create_dir_all(root.join("bin"))?;
    std::fs::create_dir_all(root.join("sbin"))?;
    std::fs::create_dir_all(root.join("etc"))?;
    std::fs::create_dir_all(root.join("proc"))?;
    std::fs::create_dir_all(root.join("sys"))?;
    std::fs::create_dir_all(root.join("tmp"))?;
    std::fs::create_dir_all(root.join("dev"))?;
    std::fs::create_dir_all(root.join("root"))?;
    // TEAM_470: Add /lib for dynamic linker support
    std::fs::create_dir_all(root.join("lib"))?;

    // Copy BusyBox binary
    std::fs::copy(&busybox_path, root.join("bin/busybox"))?;
    make_executable(&root.join("bin/busybox"))?;

    // TEAM_470: Copy musl dynamic linker for dynamically-linked binary support
    let musl_linker = if arch == "x86_64" {
        Path::new("/lib/ld-musl-x86_64.so.1")
    } else {
        Path::new("/lib/ld-musl-aarch64.so.1")
    };
    if musl_linker.exists() {
        let linker_name = musl_linker.file_name().unwrap();
        std::fs::copy(musl_linker, root.join("lib").join(linker_name))?;
        make_executable(&root.join("lib").join(linker_name))?;
        println!("  üìö musl dynamic linker installed");
    } else {
        println!("  ‚ö†Ô∏è  musl linker not found at {}, dynamic binaries may not work", musl_linker.display());
    }

    // TEAM_470: Copy additional test binaries from xtask/initrd_resources/bin/
    let extra_bin_dir = Path::new("xtask/initrd_resources/bin");
    if extra_bin_dir.exists() {
        for entry in std::fs::read_dir(extra_bin_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_file() {
                let name = path.file_name().unwrap();
                std::fs::copy(&path, root.join("bin").join(name))?;
                make_executable(&root.join("bin").join(name))?;
                println!("  üìÑ Extra binary: /bin/{}", name.to_string_lossy());
            }
        }
    }

    // Create symlinks for all applets
    #[cfg(unix)]
    {
        use std::os::unix::fs::symlink;

        for (applet, dir) in super::busybox::applets() {
            let link_path = root.join(dir).join(applet);
            let target = if *dir == "sbin" {
                "../bin/busybox"
            } else {
                "busybox"
            };
            let _ = std::fs::remove_file(&link_path);
            symlink(target, &link_path)?;
        }
    }

    // Create /init as a copy of busybox (kernel entry point)
    // TEAM_451: Can't use symlink - kernel ELF loader doesn't follow symlinks
    let _ = std::fs::remove_file(root.join("init"));
    std::fs::copy(&busybox_path, root.join("init"))?;
    make_executable(&root.join("init"))?;

    // Create /etc/inittab (TEAM_460: changed to wait so exit works)
    let inittab = r#"# LevitateOS BusyBox init configuration
# TEAM_451: Generated by xtask
# TEAM_460: Changed respawn to wait so 'exit' terminates shell

# System initialization
::sysinit:/bin/echo "LevitateOS (BusyBox) starting..."
::sysinit:/bin/mount -t proc proc /proc
::sysinit:/bin/mount -t sysfs sysfs /sys

# Test scripts at root level (kernel has issues with subdirectory files)
# Run: sh /test-core.sh [phase] to test coreutils
# Run: sh /test.sh to test basic ash functionality

# Start interactive shell
::wait:-/bin/ash

# Handle Ctrl+Alt+Del
::ctrlaltdel:/sbin/reboot

# Shutdown hooks
::shutdown:/bin/echo "System shutting down..."
"#;
    std::fs::write(root.join("etc/inittab"), inittab)?;

    // Create /etc/passwd
    let passwd = "root:x:0:0:root:/root:/bin/ash\n";
    std::fs::write(root.join("etc/passwd"), passwd)?;

    // Create /etc/group
    let group = "root:x:0:\n";
    std::fs::write(root.join("etc/group"), group)?;

    // Create /etc/profile
    let profile = r"export PATH=/bin:/sbin
export HOME=/root
export PS1='LevitateOS# '
alias ll='ls -la'
";
    std::fs::write(root.join("etc/profile"), profile)?;

    // Create sample files
    std::fs::write(root.join("etc/motd"), "Welcome to LevitateOS!\n")?;
    std::fs::write(
        root.join("root/hello.txt"),
        "Hello from BusyBox initramfs!\n",
    )?;

    // TEAM_459: Test script to verify ash shell works
    // TEAM_466: Now loaded from external file
    // TEAM_466: Moved to root level - kernel has issues with initramfs subdirectory files
    std::fs::write(root.join("test.sh"), TEST_SH)?;
    make_executable(&root.join("test.sh"))?;

    // TEAM_460: Comprehensive coreutils test suite - deliberate dependency order
    // TEAM_465: Added phase selection support
    // TEAM_466: Now loaded from external file, moved to root level
    std::fs::write(root.join("test-core.sh"), TEST_CORE_SH)?;
    make_executable(&root.join("test-core.sh"))?;

    // Show what we created
    let applet_count = super::busybox::applets().len();
    println!("  üì¶ BusyBox binary + {applet_count} applet symlinks");
    println!("  üìÑ /etc/inittab, passwd, group, profile");

    // Create CPIO archive
    let cpio_filename = format!("initramfs_{arch}.cpio");
    create_cpio_archive(&root, &cpio_filename)?;

    // Show final size
    let metadata = std::fs::metadata(&cpio_filename)?;
    let size_kb = metadata.len() / 1024;
    println!("‚úÖ BusyBox initramfs created: {cpio_filename} ({size_kb} KB)");

    Ok(())
}
