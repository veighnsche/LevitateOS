## Learnings

### SSH Key Generation Must Use Host Tools
When generating SSH host keys during rootfs construction, use the host system's ssh-keygen, not the one from the staging rootfs. The staging binaries don't have their library dependencies resolved yet (musl libc symbols missing), causing dynamic link errors. The host's ssh-keygen has full glibc support and works reliably. This pattern should apply to any tools that have complex OpenSSL/crypto dependencies.

### sshd Init Script Already Provided by Alpine
OpenSSH includes a ready-made sshd init script in /etc/init.d/ when openssh-server is installed. No need to write custom scripts—just copy the existing one via copy_tree("etc/ssh") and openrc_scripts() operations.

### Custom Operations Integrate Cleanly Into Component System
Adding a new custom operation (SetupSsh) required: (1) Create ssh.rs module in custom/; (2) Add SetupSsh variant to CustomOp enum; (3) Add module to custom/mod.rs imports; (4) Add match arm in custom::execute(). Four small changes, no architectural complexity. The component system's CustomOp dispatch pattern scales well for new operations.

### Preflight Infrastructure Already Exists
The preflight module (disk space, host tools, network checks) was already fully implemented in AcornOS/src/preflight/. Only needed to wire up the CLI command using tokio async runtime. PreflightChecker::run_all() is async and needs rt.block_on() in CLI context.

### Command Architecture Differs from LevitateOS
AcornOS has a slightly flatter command structure vs leviso (initramfs and iso as top-level vs. under build subcommand). This is fine—the functionality is equivalent. The structure was likely chosen for Alpine's different build pattern.

### Install-Tests Boot Detection Broken (TEAM_154)
The automated install-tests fail before Phase 1 due to Console I/O buffering in the test harness. Manual QEMU boot works perfectly. Don't waste time on install-tests until the Console I/O is fixed. Use `cargo run -- run` for manual verification.

### Phase 6 Post-Reboot Long-Broken
Phase 6 of install-tests (post-reboot verification) has been broken for a long time. Focus on Phases 1-5.

### IuppiterOS inherits distro-spec::iuppiter constants
All IuppiterOS builder configuration (OS_NAME, OS_ID, ISO_LABEL, BOOT_MODULES, etc.) comes from distro-spec::iuppiter module. The IuppiterConfig struct is a thin wrapper that delegates to distro_spec for all identity constants. Workspace membership must be added to root Cargo.toml for submodules to compile properly.

### Recipe Module Pattern
Recipe module mirrors leviso exactly: separate files for each dependency type (alpine.rs, linux.rs), shared infrastructure (find_recipe, run_recipe_json) in mod.rs. Each dependency's wrapper function handles path fallbacks and JSON parsing. Tools installation is separate and reuses same infrastructure. This pattern scales: can easily add new dependencies like additional package sets without duplicating recipe logic.

### APK Extraction Produces Complete FHS Rootfs
The alpine.rhai recipe (running apk.static with --root flag) correctly creates a full Filesystem Hierarchy Standard rootfs with all expected directories. The rootfs includes musl C library, busybox (with shell symlinks), apk-tools, and configured APK repositories. This is all we need—no additional initialization is required at this stage. The rootfs is ready for package installation via packages.rhai.

### IuppiterOS Can Share AcornOS Downloads via Symlink
Instead of downloading duplicate Alpine packages, IuppiterOS symlinks its downloads directory to AcornOS's. This requires: (1) symlinking IuppiterOS/downloads → AcornOS/downloads; (2) having separate recipe script files (deps/*.rhai) pointing to the shared downloads location. The recipe infrastructure already supports this pattern naturally since all paths are resolved at runtime. This is efficient and ensures both distros use identical Alpine packages, reducing disk usage and download time.

### APK Handles Dependency Resolution Automatically
When packages.rhai invokes apk-tools-static with multiple package names (e.g., "apk add dhcpcd iproute2 iputils"), APK automatically resolves all transitive dependencies and installs them in the correct order. This is proven by the APK database at lib/apk/db/installed which contains the complete dependency graph. No manual dependency ordering is needed—just pass package names to apk and it handles the rest. This is why the recipe infrastructure is so simple and reliable: APK's built-in dependency resolution does the heavy lifting.

### Alpine Signing Keys are Embedded in distro-spec
All Alpine signing keys (5 keys total) are embedded as constants in distro_spec::acorn::packages::ALPINE_KEYS. They're included from key files in distro-spec/src/acorn/keys/ as PEM-formatted strings. This allows key installation to happen entirely in Rust code without needing the keys to be in the recipe scripts. Keys need to be installed into rootfs /etc/apk/keys/ early (after basic rootfs extraction) so APK can verify package signatures.

### Key Installation Should Happen After Rootfs Extraction
The best place to install Alpine signing keys is in the recipe/alpine.rs:alpine() function, immediately after verifying the rootfs paths exist. This ensures keys are available before packages.rhai runs and installs packages. Keys can be verified at build time with unit tests that check PEM format and existence.

### Separate packages.rhai Per Distro
Each distro (AcornOS and IuppiterOS) has its own packages.rhai recipe with hardcoded package lists. This is simpler than parameterized recipes (which would add complexity to the Rhai language execution). The recipe structure is: (1) TIER0/TIER1/TIER2/TIER3 constants defined at the top with comments; (2) build() function installs each tier via apk add; (3) is_installed() verifies distro-specific key binaries. This makes it immediately clear what packages each distro installs, and allows easy customization per distro.

### Copy-Paste Errors Require Full Audit
When IuppiterOS recipe module was copied from AcornOS (iteration 3), error messages were fixed (iteration 9 opus review) but doc comments were missed. Lesson: when reviewing copy-paste modules, search for ALL references to the source name (e.g., grep for "acorn" case-insensitive), not just the specific pattern reported.

### String::contains() vs Line-by-Line Matching for Config Files
When checking if a config file setting is active (uncommented), never use `config.contains("Setting value")` — this matches inside commented lines too (e.g., `#Setting value` contains `Setting value`). Always check line-by-line: `config.lines().any(|line| line.trim() == target)`. This pattern applies to sshd_config, inittab, and any other line-oriented config format.
