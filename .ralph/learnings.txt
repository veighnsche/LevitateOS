## Learnings

### SSH Key Generation Must Use Host Tools
When generating SSH host keys during rootfs construction, use the host system's ssh-keygen, not the one from the staging rootfs. The staging binaries don't have their library dependencies resolved yet (musl libc symbols missing), causing dynamic link errors. The host's ssh-keygen has full glibc support and works reliably. This pattern should apply to any tools that have complex OpenSSL/crypto dependencies.

### sshd Init Script Already Provided by Alpine
OpenSSH includes a ready-made sshd init script in /etc/init.d/ when openssh-server is installed. No need to write custom scripts—just copy the existing one via copy_tree("etc/ssh") and openrc_scripts() operations.

### Custom Operations Integrate Cleanly Into Component System
Adding a new custom operation (SetupSsh) required: (1) Create ssh.rs module in custom/; (2) Add SetupSsh variant to CustomOp enum; (3) Add module to custom/mod.rs imports; (4) Add match arm in custom::execute(). Four small changes, no architectural complexity. The component system's CustomOp dispatch pattern scales well for new operations.

### Preflight Infrastructure Already Exists
The preflight module (disk space, host tools, network checks) was already fully implemented in AcornOS/src/preflight/. Only needed to wire up the CLI command using tokio async runtime. PreflightChecker::run_all() is async and needs rt.block_on() in CLI context.

### Command Architecture Differs from LevitateOS
AcornOS has a slightly flatter command structure vs leviso (initramfs and iso as top-level vs. under build subcommand). This is fine—the functionality is equivalent. The structure was likely chosen for Alpine's different build pattern.

### Install-Tests Boot Detection Broken (TEAM_154)
The automated install-tests fail before Phase 1 due to Console I/O buffering in the test harness. Manual QEMU boot works perfectly. Don't waste time on install-tests until the Console I/O is fixed. Use `cargo run -- run` for manual verification.

### Initramfs Implementation Already Complete in AcornOS
Phase 4 initramfs build was already fully implemented when we started:
- build_tiny_initramfs() in artifact/initramfs.rs: complete
- init_tiny.template: complete with correct 3-layer overlay logic
- Module loading infrastructure: complete with compression support (.xz, .gz)
- CPIO archive building: using distro-builder::artifact::cpio (shared infrastructure)

IuppiterOS inherited the same implementation via copy. Only needed: (1) cmd_initramfs() function in main.rs to wire up the CLI, (2) verification that IuppiterOS uses correct distro-spec::iuppiter constants. This demonstrates the power of shared infrastructure — once one distro has it working, the other just needs to import and verify it uses correct constants.

### Module Dependency Files Are Copied, Not Regenerated
The initramfs build copies modules.dep and related files from the kernel build output, rather than regenerating them with depmod. This is correct because: (1) kernel build already computed proper dependency graphs, (2) /init script uses insmod (not modprobe), so it doesn't need depmod; (3) copying is faster and more reproducible than regeneration.

### Phase 6 Post-Reboot Long-Broken
Phase 6 of install-tests (post-reboot verification) has been broken for a long time. Focus on Phases 1-5.

### IuppiterOS inherits distro-spec::iuppiter constants
All IuppiterOS builder configuration (OS_NAME, OS_ID, ISO_LABEL, BOOT_MODULES, etc.) comes from distro-spec::iuppiter module. The IuppiterConfig struct is a thin wrapper that delegates to distro_spec for all identity constants. Workspace membership must be added to root Cargo.toml for submodules to compile properly.

### Recipe Module Pattern
Recipe module mirrors leviso exactly: separate files for each dependency type (alpine.rs, linux.rs), shared infrastructure (find_recipe, run_recipe_json) in mod.rs. Each dependency's wrapper function handles path fallbacks and JSON parsing. Tools installation is separate and reuses same infrastructure. This pattern scales: can easily add new dependencies like additional package sets without duplicating recipe logic.

### APK Extraction Produces Complete FHS Rootfs
The alpine.rhai recipe (running apk.static with --root flag) correctly creates a full Filesystem Hierarchy Standard rootfs with all expected directories. The rootfs includes musl C library, busybox (with shell symlinks), apk-tools, and configured APK repositories. This is all we need—no additional initialization is required at this stage. The rootfs is ready for package installation via packages.rhai.

### IuppiterOS Can Share AcornOS Downloads via Symlink
Instead of downloading duplicate Alpine packages, IuppiterOS symlinks its downloads directory to AcornOS's. This requires: (1) symlinking IuppiterOS/downloads → AcornOS/downloads; (2) having separate recipe script files (deps/*.rhai) pointing to the shared downloads location. The recipe infrastructure already supports this pattern naturally since all paths are resolved at runtime. This is efficient and ensures both distros use identical Alpine packages, reducing disk usage and download time.

### APK Handles Dependency Resolution Automatically
When packages.rhai invokes apk-tools-static with multiple package names (e.g., "apk add dhcpcd iproute2 iputils"), APK automatically resolves all transitive dependencies and installs them in the correct order. This is proven by the APK database at lib/apk/db/installed which contains the complete dependency graph. No manual dependency ordering is needed—just pass package names to apk and it handles the rest. This is why the recipe infrastructure is so simple and reliable: APK's built-in dependency resolution does the heavy lifting.

### Alpine Signing Keys are Embedded in distro-spec
All Alpine signing keys (5 keys total) are embedded as constants in distro_spec::acorn::packages::ALPINE_KEYS. They're included from key files in distro-spec/src/acorn/keys/ as PEM-formatted strings. This allows key installation to happen entirely in Rust code without needing the keys to be in the recipe scripts. Keys need to be installed into rootfs /etc/apk/keys/ early (after basic rootfs extraction) so APK can verify package signatures.

### Key Installation Should Happen After Rootfs Extraction
The best place to install Alpine signing keys is in the recipe/alpine.rs:alpine() function, immediately after verifying the rootfs paths exist. This ensures keys are available before packages.rhai runs and installs packages. Keys can be verified at build time with unit tests that check PEM format and existence.

### Separate packages.rhai Per Distro
Each distro (AcornOS and IuppiterOS) has its own packages.rhai recipe with hardcoded package lists. This is simpler than parameterized recipes (which would add complexity to the Rhai language execution). The recipe structure is: (1) TIER0/TIER1/TIER2/TIER3 constants defined at the top with comments; (2) build() function installs each tier via apk add; (3) is_installed() verifies distro-specific key binaries. This makes it immediately clear what packages each distro installs, and allows easy customization per distro.

### Copy-Paste Errors Require Full Audit
When IuppiterOS recipe module was copied from AcornOS (iteration 3), error messages were fixed (iteration 9 opus review) but doc comments were missed. Lesson: when reviewing copy-paste modules, search for ALL references to the source name (e.g., grep for "acorn" case-insensitive), not just the specific pattern reported.

### String::contains() vs Line-by-Line Matching for Config Files
When checking if a config file setting is active (uncommented), never use `config.contains("Setting value")` — this matches inside commented lines too (e.g., `#Setting value` contains `Setting value`). Always check line-by-line: `config.lines().any(|line| line.trim() == target)`. This pattern applies to sshd_config, inittab, and any other line-oriented config format.

### Firmware Packages vs Firmware Copying
Alpine's linux-firmware and related packages pull in firmware for ALL hardware (GPUs, audio, network, etc.) - they're very comprehensive. For a live ISO where size matters, you can: (1) Keep the packages installed (satisfying distro-spec), (2) Use the FIRMWARE component's CopyWifiFirmware to copy only essential WiFi drivers. Additional drivers can be added post-boot via 'apk add' if a user needs them for specific hardware. This reduced AcornOS EROFS from 769MB (all firmware) to 190MB (WiFi only), staying well under the 500MB target while maintaining flexibility.

### Copy-Paste New Crates Need FULL Audit of `use` Statements
When creating IuppiterOS by copying AcornOS's entire src/, every `use distro_spec::acorn::` import must be changed to `use distro_spec::iuppiter::`. This isn't just a doc comment issue — it's a *functional* bug: wrong ISO label, wrong boot modules, wrong ISO filename, wrong QEMU settings. Grep for `distro_spec::acorn` in the new crate and fix every occurrence. Similarly audit constants, branding strings, package lists, and test assertions.

### IuppiterOS Package Exclusions Are Functional, Not Cosmetic
IuppiterOS explicitly excludes: iwd/wireless-regdb (no WiFi), cryptsetup/lvm (no LUKS/LVM), mkfs.btrfs/sgdisk (no Btrfs). These aren't just "not needed" — including them would pull in unnecessary dependencies, increase image size, and violate the appliance design. When copying AcornOS component definitions, actively remove excluded packages from ADDITIONAL_SBINS, OPENRC_SCRIPTS, and NETWORK/FIRMWARE components.

### Test Instrumentation Needs Distro-Specific Branding
When creating test instrumentation for IuppiterOS based on AcornOS, don't just copy-paste the script. Update all variable names and comments to use distro-specific branding (IUPPITER_TEST_MODE vs ACORN_TEST_MODE). The markers (___SHELL_READY___, ___CMD_START___, etc.) should remain identical for compatibility with install-tests, but internal variables should reflect the distro. This keeps code maintainable and makes it clear which distro each component belongs to.

### EROFS Size Reduction Through Package Discipline
IuppiterOS achieved 79% smaller EROFS than AcornOS (39MB vs 190MB) not through clever optimizations, but through disciplined package selection: no desktop, no wireless, no encryption, no sound. The appliance focus naturally leads to smaller images. This demonstrates that distro-spec's package tier separation is effective — AcornOS's extra 151MB consists entirely of packages excluded from IuppiterOS.

### Live Overlay Overrides EROFS Base — Check Both Paths
When fixing config files like /etc/inittab, check BOTH the EROFS rootfs path (definitions.rs components) AND the live overlay path (iso.rs create_live_overlay). The overlay filesystem means /live/overlay/etc/inittab takes precedence over the EROFS /etc/inittab. Fixing only definitions.rs is ineffective if iso.rs also writes the same file to the overlay.

### Copy-Paste Audits Must Cover ALL Source Files
Four opus reviews caught copy-paste bugs in IuppiterOS, each finding new files missed by previous reviews. The pattern: reviews focused on "files changed in last N commits" but copy-paste bugs exist in files that were copied once and never touched again. The definitive fix is `grep -ri acorn IuppiterOS/src/` covering ALL source files, not just recently changed ones.

### QEMU Serial Mode: stdout vs File
When building QEMU commands for interactive testing, use `-serial stdio` (or `-serial mon:stdio` with monitor) instead of `-serial file:...`. This sends serial output directly to the console where the user can see boot messages and interact with the login prompt. File-based serial output is better for automated testing where you need to parse messages, but for manual debugging and interactive boot testing, stdio is more useful and user-friendly.

### AcornOS Live Boot Verification
The AcornOS smoke test `cargo run -- test` successfully boots the system and verifies:
- Kernel loads and hardware initialized
- Initramfs mounts EROFS from loop device
- Overlay filesystem created (three-layer for live boot)
- OpenRC starts and runs services
- ___SHELL_READY___ marker appears on serial
The test finds minor service issues (missing ifup, missing sshd-session) but core boot chain works correctly. Boot time: ~8.4 seconds. These service issues are configuration, not fundamental problems with the base system.

### Always Use distro-spec Constants for Labels and Identity
Never hardcode ISO labels, OS names, or other identity strings in format strings. Always import and use the constants from distro-spec (e.g., `ISO_LABEL`, `OS_NAME`, `OS_ID`). This applies to kernel cmdline construction (`root=LABEL=...`), GRUB configs, branding, and any other place where the distro identity appears. Hardcoded values silently go out of sync when distro-spec changes.

### QEMU serial_only Requires Explicit -display none
When building a QEMU command with `-serial stdio` for headless serial-only mode, you must also pass `-display none` to prevent QEMU from opening a graphical window. Without it, QEMU defaults to opening an SDL/GTK display even when serial is on stdio. Compare with `-nographic` which combines both `-serial stdio` and `-display none`, but `-nographic` also redirects the QEMU monitor which may not be desired for interactive runs.

### Verify Alpine Package Availability Before Adding to distro-spec
Not all packages exist in Alpine repos. sdparm was listed in distro-spec REFURBISHMENT_PACKAGES but doesn't exist in Alpine v3.23 main or community repos. When adding packages to distro-spec, verify availability with `curl -s "https://dl-cdn.alpinelinux.org/alpine/v3.23/{main,community}/x86_64/" | grep packagename`. If a package is removed from the recipe, always update corresponding tests and distro-spec definitions.

### When Removing a Package, Update ALL References
Removing sdparm from packages.rhai required changes in 3 places: (1) the recipe itself (packages.rhai), (2) the unit test asserting its presence (lib.rs), (3) the distro-spec constant array (packages.rs). Missing any one of these causes test failures or spec drift. Pattern: grep for the package name across all submodules before declaring the removal complete.

### Custom Operations Need Complete Implementation Before Adding to Components
When adding a new CustomOp variant that's referenced in a component definition, ALL three pieces must be added atomically: (1) the variant in the CustomOp enum, (2) the match arm in custom::execute(), (3) the actual implementation function. Adding the component reference without the enum variant causes a compilation error. Consider using declarative WriteFileMode ops for simple static file content instead of custom ops — this avoids the dispatch boilerplate entirely and keeps the component definition self-contained.

### OPENRC_SCRIPTS Only Works for Alpine-Provided Init Scripts
The OPENRC_SCRIPTS array feeds into copy_init_script() which copies from the Alpine source rootfs's /etc/init.d/. Custom service scripts (like iuppiter-engine) that aren't from Alpine packages must NOT be in this array — they will fail with "init script not found". Instead, write custom init scripts using WriteFileMode ops directly in the component that owns the service.

### UKI Extra Cmdline vs Base Cmdline: Avoid Double-Sourcing Console Parameters
When distro-spec UKI entries include console parameters in their `extra_cmdline` field, the UKI builder must NOT also add those same console parameters to the base cmdline. This is especially important for IuppiterOS where every entry includes `console=ttyS0,115200n8` in extra_cmdline. The AcornOS pattern is different — its entries have empty extra_cmdline, so console params go in the base cmdline. When reviewing UKI builders, always check: does `base_cmdline + extra_cmdline` produce duplicate parameters?

### Install-Tests Uses Distro-Agnostic Architecture with DistroContext Trait
The install-tests framework uses a trait-based design (`DistroContext`) to support multiple distros (LevitateOS, AcornOS, IuppiterOS) with a single test codebase. Each distro implements the trait with its own: boot patterns, service commands, init verification, bootloader setup, paths. The `context_for_distro()` factory function returns the appropriate context based on CLI `--distro` flag. This design allows adding new distros without duplicating test code—just implement the trait. Both AcornOS and LevitateOS contexts were already complete from earlier iterations, enabling the `--distro acorn` flag to work without additional work.

### Multi-Distro Testing Infrastructure Requires Coordinated Updates
When adding multi-distro support to install-tests (AcornOS alongside LevitateOS), multiple components need updates: (1) DistroContext trait implementation (already done for AcornOS), (2) preflight verification module (made distro-agnostic), (3) ISO verification checklist in fsdbg crate (hardcoded for LevitateOS structure, not yet updated). Adding a new distro requires changes across multiple crates, not just the test runner. Manual boot testing remains more reliable than install-tests until the entire test stack is refactored for multi-distro.

### Preflight Verification Should Be Distro-Aware from Design
The preflight verification module initially hardcoded LevitateOS details (`distro_spec::levitate::ISO_FILENAME`) instead of accepting distro context. Better design: either (1) pass DistroContext to preflight functions, (2) accept optional ISO filename and fall back to discovery, or (3) use a builder pattern for flexible configuration. The fallback-to-discovery approach is least invasive but requires ISO checklist to also be distro-agnostic.

### ISO Verification Checklists Cannot Be Single-Distro
The fsdbg checklist module hardcodes checks for specific file paths and volume IDs (e.g., Volume ID=LEVITATEOS, /EFI/Linux/levitateos-*.efi). Adding a new distro with different ISO structure (AcornOS uses /boot/uki/ instead of /EFI/Linux/, different volume ID) requires either: (1) distro-parameterized checklists, (2) separate checklist implementations per distro, (3) content verification without path checks. This is a design limitation of the current fsdbg checklist infrastructure.

### Additive API Design for Multi-Distro Test Infrastructure
When extending test infrastructure to support multiple distros, prefer adding new functions alongside existing ones rather than changing signatures. For example, `require_preflight_for_distro(dir, id)` alongside existing `require_preflight(dir)` which delegates to `require_preflight_for_distro(dir, "levitate")`. This avoids breaking all existing callers and allows incremental adoption. The same pattern works for verification functions: `verify_distro(reader, id)` alongside `verify(reader)`.

### ISO Checklist Constants Must Be Loaded Per-Distro
Different distros have different ISO structures: LevitateOS has installed initramfs + installed UKIs in boot/uki/, while AcornOS/IuppiterOS only have live initramfs + live UKIs in EFI/Linux/. The volume ID, UKI filenames, and required boot files all differ per distro. Use a constants struct pattern (`DistroIsoConstants`) with a factory function per distro instead of global constants.

### Test Infrastructure Blockers vs Product Defects
The distinction between infrastructure blockers and product code issues is critical for iteration planning. TEAM_154 boot detection issue is a test harness I/O buffering problem, not a defect in the AcornOS/IuppiterOS builders. Manual testing via `cargo run -- run` proves the ISOs are functionally correct. When encountering test failures: (1) first verify the product works via manual testing, (2) if manual works but automated tests fail, the blocker is likely in the test infrastructure, (3) if manual also fails, it's a product bug. Spend iteration effort on product bugs and required features, not on debugging test harness infrastructure unless it's a planned iteration focus.

